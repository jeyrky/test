local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInput = game:GetService("VirtualInputManager")
local lp = Players.LocalPlayer
local char = lp.Character or lp.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local hrp = char:WaitForChild("HumanoidRootPart")
print("[auto] init")
local playerGui = lp:WaitForChild("PlayerGui")
local autoRunning = true
local autoRunning = true
local attHRP, ap, ao
local function setupFlight()
    attHRP = attHRP or Instance.new("Attachment")
    attHRP.Parent = hrp
    ap = ap or Instance.new("AlignPosition")
    ap.Attachment0 = attHRP
    ap.ApplyAtCenterOfMass = true
    ap.MaxForce = 5e7
    ap.Responsiveness = 25
    ap.Parent = hrp
    ao = ao or Instance.new("AlignOrientation")
    ao.Attachment0 = attHRP
    ao.MaxTorque = 5e7
    ao.Responsiveness = 25
    ao.Parent = hrp
    if not hrp:FindFirstChild("AntiGravity") then
        local vg = Instance.new("VectorForce")
        vg.Name = "AntiGravity"
        vg.Attachment0 = attHRP
        vg.Force = Vector3.new(0, workspace.Gravity * hrp.AssemblyMass, 0)
        vg.RelativeTo = Enum.ActuatorRelativeTo.World
        vg.Parent = hrp
    else
        hrp.AntiGravity.Force = Vector3.new(0, workspace.Gravity * hrp.AssemblyMass, 0)
    end
end
setupFlight()
lp.CharacterAdded:Connect(function(c)
    char = c
    humanoid = c:WaitForChild("Humanoid")
    hrp = c:WaitForChild("HumanoidRootPart")
    setupFlight()
end)
local followDistance = 4
local checkInterval = 1.0
local nameKeywords = {"slime","blazing slime"}
local function norm(s)
    s = tostring(s or "")
    s = s:gsub("<.->","")
    s = s:gsub("%s+"," "):gsub("^%s+",""):gsub("%s+$","")
    s = s:lower()
    return s
end
local nNameKeys = {}
for _,k in ipairs(nameKeywords) do
    local t = norm(k)
    if t ~= "" then table.insert(nNameKeys, t) end
end
local function matchAny(raw, keys)
    if not raw or #keys == 0 then return false end
    local s = norm(raw)
    for _,k in ipairs(keys) do
        if s:find(k, 1, true) then return true end
    end
    return false
end
local Candidates = {}
local function attachCandidate(model, root, label)
    if not model or not root then return end
    Candidates[model] = {model=model, root=root, label=label}
end
local function tryAddFromLabel(label)
    local raw = (label.ContentText ~= nil) and label.ContentText or label.Text
    if not matchAny(raw, nNameKeys) then return end
    local model = label:FindFirstAncestorOfClass("Model"); if not model then return end
    local root  = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
    if not root then return end
    attachCandidate(model, root, label)
end
local function tryAddFromModel(model)
    local root = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
    if not root then return end
    local ok = matchAny(model.Name, nNameKeys)
    if not ok then
        for _,gui in ipairs(model:GetDescendants()) do
            if gui:IsA("TextLabel") then
                local t = (gui.ContentText ~= nil) and gui.ContentText or gui.Text
                if matchAny(t, nNameKeys) then ok = true; break end
            end
        end
    end
    if ok then attachCandidate(model, root, nil) end
end
local function initialScan()
    Candidates = {}
    for _, d in ipairs(workspace:GetDescendants()) do
        if d:IsA("TextLabel") then
            tryAddFromLabel(d)
        elseif d:IsA("Model") then
            tryAddFromModel(d)
        end
    end
end
initialScan()
local addQueue = {}
local removingSet = setmetatable({}, {__mode = "k"})
workspace.DescendantAdded:Connect(function(obj)
    table.insert(addQueue, obj)
end)
workspace.DescendantRemoving:Connect(function(obj)
    local m = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
    if m then removingSet[m] = true end
end)
local MAX_PER_TICK = 60
task.spawn(function()
    while true do
        for m,_ in pairs(removingSet) do
            Candidates[m] = nil
            removingSet[m] = nil
        end
        local processed = 0
        while processed < MAX_PER_TICK and #addQueue > 0 do
            processed = processed + 1
            local obj = table.remove(addQueue, 1)
            if obj and obj.Parent then
                if obj:IsA("TextLabel") then
                    pcall(tryAddFromLabel, obj)
                elseif obj:IsA("Model") then
                    pcall(tryAddFromModel, obj)
                end
            end
        end
        task.wait(0.02)
    end
end)
local function findClosestPet()
    local nearest, bestDist = nil, math.huge
    for _, info in pairs(Candidates) do
        local model = info.model
        local root  = info.root
        if model and root and model:IsDescendantOf(workspace) then
            local pos = root.Position
            local dist = (hrp.Position - pos).Magnitude
            if dist < bestDist then
                bestDist = dist
                nearest  = info
            end
        end
    end
    return nearest
end
local function findTool(names)
    local function f(container)
        if not container then return nil end
        for _,v in ipairs(container:GetChildren()) do
            if v:IsA("Tool") then
                local n = v.Name:lower()
                for _,k in ipairs(names) do
                    if n:find(k) then return v end
                end
            end
        end
        return nil
    end
    return f(lp.Backpack) or f(char) or f(lp:FindFirstChild("StarterGear")) or f(lp:FindFirstChild("Weapon")) or f(lp:FindFirstChild("Tools"))
end
local currentWeapon = nil
local function ensureEquipWeapon()
    if currentWeapon and currentWeapon.Parent == char then return currentWeapon end
    local t = currentWeapon
    if not t or t.Parent ~= char then
        t = findTool({"weapon","sword","blade"})
        if t and t.Parent ~= char then pcall(function() humanoid:EquipTool(t) end) end
        currentWeapon = t
    end
    return currentWeapon
end
local function parseHP(model)
    for _,gui in ipairs(model:GetDescendants()) do
        if gui:IsA("TextLabel") then
            local txt = (gui.ContentText ~= nil) and gui.ContentText or gui.Text
            if txt and txt:lower():find("hp") then
                local n = tonumber((txt:lower():match("([%d%.]+)%s*hp")))
                if n then return n end
            end
        end
    end
    return nil
end
local function tapCenter()
    local cam = workspace.CurrentCamera
    if not cam then return end
    local v = cam.ViewportSize
    local x, y = v.X/2, v.Y/2
    VirtualInput:SendMouseButtonEvent(x, y, 0, true, game, 0)
    VirtualInput:SendMouseButtonEvent(x, y, 0, false, game, 0)
end
local function enforceNoClip()
    if not noclipEnabled then return end
    for _,p in ipairs(char:GetDescendants()) do
        if p:IsA("BasePart") then
            p.CanCollide = false
        end
    end
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
end
RunService.Stepped:Connect(function()
    if noclipEnabled then enforceNoClip() end
end)
local SURFACE_ALT = 6
local FLIGHT_SPEED = 16
local flightTick = 0.05
local rcParams = RaycastParams.new()
rcParams.FilterType = Enum.RaycastFilterType.Exclude
rcParams.IgnoreWater = true
rcParams.FilterDescendantsInstances = {char}
local function getSurfaceY(pos)
    rcParams.FilterDescendantsInstances = {char}
    local origin = pos + Vector3.new(0, 200, 0)
    local dir = Vector3.new(0, -400, 0)
    local hit = workspace:Raycast(origin, dir, rcParams)
    if hit and hit.Position then
        return hit.Position.Y
    end
    return pos.Y
end
local function moveTo(pos, timeout)
    humanoid:MoveTo(pos)
    local done = false
    local conn
    conn = humanoid.MoveToFinished:Connect(function() done = true end)
    local startT = os.clock()
    while not done and os.clock() - startT < (timeout or 1.5) do
        task.wait(0.05)
    end
    if conn then conn:Disconnect() end
end
local function flyStepTo(targetPos)
    local surfaceY = getSurfaceY(targetPos)
    local targetY = math.max(surfaceY + SURFACE_ALT, hrp.Position.Y)
    local delta = Vector3.new(targetPos.X - hrp.Position.X, 0, targetPos.Z - hrp.Position.Z)
    local dist = delta.Magnitude
    if dist <= followDistance then return end
    local dir = dist > 0 and delta.Unit or Vector3.new()
    local step = math.min(FLIGHT_SPEED * flightTick, dist)
    local nextPos = Vector3.new(hrp.Position.X, targetY, hrp.Position.Z) + dir * step
    if ap then ap.Position = nextPos end
    if ao then ao.CFrame = CFrame.lookAt(hrp.Position, nextPos) end
end
local function attackLoop(pet)
    local alive = true
    task.spawn(function()
        while alive and pet.model:IsDescendantOf(workspace) do
            if not hrp or not humanoid then break end
            if not autoRunning then break end
            local pos = pet.root.Position
            flyStepTo(pos)
            task.wait(flightTick)
        end
    end)
    local start = os.clock()
    print("[auto] engage target")
    while pet.model:IsDescendantOf(workspace) do
        if not hrp or not humanoid then break end
        if not autoRunning then task.wait(0.2) continue end
        local pos = pet.root.Position
        local distNow = (hrp.Position - pos).Magnitude
        if distNow <= followDistance + 0.5 then
            local t = ensureEquipWeapon()
            if t then pcall(function() t:Activate() end) end
            tapCenter()
        end
        local hp = parseHP(pet.model)
        if hp and hp <= 0 then break end
        if os.clock() - start > 30 then break end
        task.wait(0.12)
    end
    alive = false
end
local lastPet
task.spawn(function()
    while true do
        task.wait(checkInterval)
        if not autoRunning then continue end
        local pet = findClosestPet()
        if pet and (not lastPet or pet.model ~= lastPet.model) then
            lastPet = pet
            attackLoop(pet)
        elseif not pet then
            lastPet = nil
        end
    end
end)
local gui = Instance.new("ScreenGui")
gui.Name = "AutoToggle"
gui.ResetOnSpawn = false
gui.Parent = playerGui
local btn = Instance.new("TextButton")
btn.Name = "AutoButton"
btn.Size = UDim2.new(0, 120, 0, 40)
btn.Position = UDim2.new(0, 10, 1, -50)
btn.Text = "Auto: ON"
btn.BackgroundColor3 = Color3.fromRGB(0,170,85)
btn.TextColor3 = Color3.fromRGB(255,255,255)
btn.Parent = gui
btn.Activated:Connect(function()
    autoRunning = not autoRunning
    btn.Text = autoRunning and "Bắt đầu: ON" or "Bắt đầu: OFF"
    btn.BackgroundColor3 = autoRunning and Color3.fromRGB(0,170,85) or Color3.fromRGB(170,0,0)
end)
local btn2 = Instance.new("TextButton")
btn2.Name = "NoclipButton"
btn2.Size = UDim2.new(0, 120, 0, 40)
btn2.Position = UDim2.new(0, 140, 1, -50)
btn2.Text = "Noclip: ON"
btn2.BackgroundColor3 = Color3.fromRGB(0,120,200)
btn2.TextColor3 = Color3.fromRGB(255,255,255)
btn2.Parent = gui
btn2.Activated:Connect(function()
    noclipEnabled = not noclipEnabled
    btn2.Text = noclipEnabled and "Noclip: ON" or "Noclip: OFF"
    btn2.BackgroundColor3 = noclipEnabled and Color3.fromRGB(0,120,200) or Color3.fromRGB(120,120,120)
end)
